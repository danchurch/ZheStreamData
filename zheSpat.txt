## the goal here is to see if we can uncover spatial
## signatures in Zhe's nitrogen and sulfur metabolism data

mv 'Normalized_For Dan.xlsx' 'Normalized_For_Dan.xlsx'
mv 'water chemistry.xlsx' 'waterChemistry.xlsx'

## read it into a df

import pandas as pd
import scipy.stats as ss
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sns
from sklearn.linear_model import LinearRegression
from scipy import stats
plt.ion()

enz = pd.read_excel("Normalized_OnlyEnzymes.xlsx")
enz.rename(columns = {'Unnamed: 0':'enzyme'}, inplace='True')
enz['enzyme'] = enz['enzyme'].str.replace(',','')
enz.set_index('enzyme', inplace=True)
enz.head()

## hmm, a couple concerns... 
## need to cut off environmental data (first several rows) 
## first we need split this by nitrogen or sulphur, other metabolism
## related enzymes, also by depth class, 

## first step would be univariate linear models for each
## but we are expecting a drop in the central region of 
## so not linear by some definitions. Something like 
## a negative and positive quadratic. 

## Zhe just sent me an updated spreadsheet:
waterChemistry = pd.read_excel("waterChemistry.xlsx")
## so our spreadsheet is now very simple.
waterChemistry = waterChemistry[['Section', 'NO3', 'SO4']]

waterChemistry

## according to our 

## focus for a minute on nitrogen metabolism
## use depth = 5

enzEnv = pd.read_excel('enzymeEnv.xlsx')
enzEnv.rename(columns = {'Unnamed: 0':'position'}, inplace='True')
enzEnv.set_index('position', inplace=True)
enzEnv.rename(index = {'Distance(m)(all distance to the upstream)':'Distance',
                       'Depth(m)':'Depth'}, 
                       inplace='True')
enzEnv.head()

Nenz = enz[enz.Function == "N metabolism"]


##Nshallow = enz[enz.Function == "N metabolism"][['Mid-A_5','Mid-B_5','Down_5','KU_5']]

##enzEnvShallow = enzEnv[['Mid-A_5','Mid-B_5','Down_5','KU_5']]

enzEnvShallow

Nshallow

waterChemistry

## we only have nitrate data for 

## nitrogen levels for this:

waterChemistry

Nshallow

## we want to test a correlation with stream Nitrate values
## we expect nitrification rates to increase with 

## we are focusing on the shallow depth (5 cm), so we have to 
## throw out our upper stream sample site. 
## and comparing to the confluence seems odd to me. 
## so we are down to mid- and down- stream sections. 

## that doesn't leave us much to work with....

## Seems appropriate to use the mean our two 

## also, not sure if amoA is of interest here.
## we have almost none-existent ammonia levels
## not sure if amoA

## so drop Amo, average the mid columns, and the confluence site:

 
Nenz = (enz[enz.Function == "N metabolism"][["Mid-A_5","Mid-B_5","Down_5"]]
        .drop(axis='rows', labels='Ammonia monooxygenase (amoA)'))

## our mean gene count for the mid site is:

N_Mid_5 = Nenz[['Mid-A_5','Mid-B_5']].mean(axis='columns')

## a new, greatly simplified df:

nRedu = pd.concat([N_Mid_5, Nenz['Down_5']], axis='columns') 
nRedu.rename(columns = {0:'mid', 'Down_5':'down'}, inplace='True')
nRedu

## so every enzyme in the denitrification pathway shows lower counts
## downstream?

ss.ttest_rel(nRedu['mid'], nRedu['down'])

## check in with Zhe, make sure these are all such genes (denitrifying)


## repeat for sulfur. 
## for sulfur oxidizing enzymes: we expect an increase
## in sulfur oxidation, higher gene counts.
## let's see: 

Senz = enz[enz.Function == "S metabolism"][["Mid-A_5","Mid-B_5","Down_5"]]
S_Mid_5 = Senz[['Mid-A_5','Mid-B_5']].mean(axis='columns')
sRedu = pd.concat([S_Mid_5, Senz['Down_5']], axis='columns') 
sRedu.rename(columns = {0:'mid', 'Down_5':'down'}, inplace='True')
sRedu

## yeah, that is not clear. I need to talk to Zhe about his expectations
## fore these genes. I don't feel like reading about each of them. 

## involve all samples, including upstream,
## = all depth
## break out the midstream samples
## model all by distance along 



############

## where were we? 

## more work on the nitrification pathway - do an RDA of of de-nitrification 
## genes as a function of distance downstream 

## run this for both depths. 

## which means we need to parse out two matrices, one for each depth. 

## also, how different are the two depths of the stream? 

## run an nms, permanova, etc

## then start thinking about sulfur.

## step 1, separate out depths.

## for the 15 cm samples:

deepSamples = enzEnv.loc["Depth"][enzEnv.loc["Depth"] == 0.15].index.to_list()
shallowSamples = enzEnv.loc["Depth"][enzEnv.loc["Depth"] == 0.05].index.to_list()[:-1]

deepNenz = (enz[enz.Function == "N metabolism"][deepSamples]
        .drop(axis='rows', labels='Ammonia monooxygenase (amoA)'))
shallowNenz = (enz[enz.Function == "N metabolism"][shallowSamples]
        .drop(axis='rows', labels='Ammonia monooxygenase (amoA)'))
## let's just keep the abbreviations:
aa = (deepNenz.reset_index()['enzyme']
        .str.split(pat="(", n=1, expand=True)[1]
        .str.replace(")","")
    )
aa.name = "enzyme"
deepNenz.index = aa
shallowNenz.index = aa

## visualize 
deepDist = enzEnv[deepSamples].loc['Distance']
deepNenzT = deepNenz.transpose()
deepNenzT.index = deepDist
deepNenzT


fig1, ax1 = plt.subplots()
deepNenzT.plot.line(title='15cm N-reducing gene counts', ax=ax1)

help(deepNenzT.plot.line)

## jeezus this is frustrating, we need that missing 
## nitrogen measurement. 

## all the potential denitrification enzymes 
## show the exact same spatial pattern, 
## but we lack the solute level data

## repeat with the shallow samples, how do they look?:

fig2, ax2 = plt.subplots()

shallowDist = enzEnv[shallowSamples].loc['Distance']

shallowNenz
shallowNenzT = shallowNenz.transpose()
shallowNenzT.index = shallowDist
shallowNenzT.plot.line(title='5cm N-reducing gene counts', ax=ax2)

ax2.set_xlim(ax1.get_xlim())

## let's put these together:

fig, ax = plt.subplots(2,1, sharex=True)
deepNenzT.plot.line(title='15cm N-reducing gene counts', ax=ax[0], legend=False)
shallowNenzT.plot.line(title='5cm N-reducing gene counts', ax=ax[1])

plt.close('all')

## great

## so, now what? try an RDA for both of these

deepNenzT.to_csv("deepNenz.csv")
shallowNenzT.to_csv("shallowNenz.csv")

deepNenz

## for that we need genes as columns, sites as rows?
## same with the spatial data? 

### R ###

library("vegan")

## let's try a simple RDA of the gene abundances 
## against distance down-stream

deepNenz <- read.csv('deepNenz.csv')
shallowNenz <- read.csv('shallowNenz.csv')

## first let's transform the gene abundances to 
## approximately meet linear/euclidean requirenments
deepNenz.hell <- decostand(deepNenz[-1], 'hellinger')
shallowNenz.hell <- decostand(shallowNenz[-1], 'hellinger')
distance <- deepNenz[[1]]
deepNenz.hell.rda <- rda(deepNenz.hell ~ distance)
plot(deepNenz.hell.rda)
## points to the only obvious global trend, 
## the increase in nar operon with distance

## and also the sulphur? I doubt the rda function
## is built to accomodate any non-normal residuals,
## and this is also count data, so...

deepSenz.hell <- decostand(deepSenz[-1], 'hellinger')
distance <- deepSenz[[1]]
deepSenz.hell.rda <- rda(deepSenz.hell ~ distance)
shallowSenz.hell <- decostand(shallowSenz[-1], 'hellinger')
distance <- shallowSenz[[1]]
shallowSenz.hell.rda <- rda(shallowSenz.hell ~ distance)

plot(shallowSenz.hell.rda) ## no strong distance dependency in the sulfur, not a surprise


#$png(file = 'deepDenitrificationRDA.png', height=600, width=1200)
#plot(deepNenz.hell.rda)
#dev.off()

## and without N-hellinger transformation
distance <- deepNenz[[1]]
deepNenz.rda <- rda(deepNenz[-1] ~ distance)
plot(deepNenz.rda)
## the transformed model appears more informative. 
## and this what legendre, borcard, etc, recommend

coef(deepNenz.hell.rda)


RsquareAdj(deepNenz.hell.rda)$adj.r.squared ## fairly large r2, but...

anova(deepNenz.hell.rda, permutations = how(nperm = 999)) ## p=0.1167
anova(deepNenz.hell.rda, by = "axis", permutations = how(nperm = 999)) ## p = 0.1667

## let's look at our sulfur matrix, that we created below?
deepSenz <- read.csv('deepSenz.csv')
shallowSenz <- read.csv('shallowSenz.csv')

## without the hellingar transformations of the sulphur data
#deepNenz.sulf.rda <- rda(deepNenz.hell, deepSenz)
#deepNenz.sulf.rda <- rda(deepNenz.hell ~  deepNenz$Distance)
#deepNenz.sulf.rda <- rda(deepNenz.hell ~ deepNenz$Distance + deepSenz$soxYZAXB + deepSenz$sat + deepSenz$sqr + deepSenz$soxC)
#deepNenz.sulf.rda <- rda(deepNenz.hell ~ deepSenz$soxYZAXB + deepSenz$sat + deepSenz$sqr + deepSenz$soxC + deepNenz$Distance)
deepNenz.sulf.rda <- rda(deepNenz.hell ~ distance + soxYZAXB, data=deepSenz)


## with the hellingar transformations of the sulphur data
## I think these are better, fits the assumptions of the rda.
deepNenz.sulf.rda <- rda(deepNenz.hell ~ distance + soxYZAXB, data=deepSenz.hell)

## does order matter here?
deepNenz.sulf.rda <- rda(deepNenz.hell ~ soxYZAXB + distance, data=deepSenz.hell)
## not really

anova.cca(deepNenz.sulf.rda)

#anova.cca(deepNenz.sulf.rda, permutations = how(nperm = 999)) 
## this doesn't return a pvalue after three explanatory terms, 
## too few degrees of freedom

anova.cca(deepNenz.sulf.rda, permutations = how(nperm = 999), by="term") ## same

?anova.cca

deepNenz.sulf.rda

summary(deepNenz.sulf.rda)

RsquareAdj(deepNenz.sulf.rda)$adj.r.squared 
## fairly large r2 (0.537), but not enough statistical power 
## to use as a model


png(file='NreductionRDA.png', width=1000, height=600)

par(mfrow=c(1,2))

## plot this, scale type 1
plot(deepNenz.sulf.rda,
    scaling = 1,
    display = c("sp", "lc", "cn"),
    main = "deepN RDA, sulfur and distance predictors")
spe.sc1 <-
    scores(deepNenz.sulf.rda,
        choices = 1:2,
        scaling = 1,
        display = "sp"
)
arrows(0, 0,
    spe.sc1[, 1] * 0.92,
    spe.sc1[, 2] * 0.92,
    length = 0,
    lty = 1,
    col = "red"
)

## this is scaling type 1, basically look for projection 
## of the nitrogen genes onto the predictor axes
## borcard p217 for interpretation

## repeat this on the shallow sediments


shallowNenz

shallowSenz

#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance, data=shallowSenz) ## distance alone can't explain anything. Makes sense.
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + soxYZAXB, data=shallowSenz)

### all of the genes showing the triangle shape are collinears:

shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + soxYZAXB, data=shallowSenz)

#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + soxC, data=shallowSenz)
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ soxYZAXB + soxC, data=shallowSenz)
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ soxYZAXB + sat, data=shallowSenz)
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ soxYZAXB + dsrAB, data=shallowSenz)
###


#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + soxYZAXB + sat + sqr + soxC, data=shallowSenz)
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + soxC + sat + sqr + soxYZAXB, data=shallowSenz)
#shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ Distance + sat, data=shallowSenz)

## with the hellingar transformations of the sulphur data
shallowNenz.sulf.rda <- rda(shallowNenz.hell ~ distance + soxYZAXB, data=shallowSenz.hell)


shallowNenz.sulf.rda

vif.cca(shallowNenz.sulf.rda) ## meh, we are simply limited by our few samples. examined manually above

anova.cca(shallowNenz.sulf.rda)

## plot this, scale type 1

#par(mfrow=c(1,2))
#par(mfrow=c(1,1))
plot(shallowNenz.sulf.rda,
    scaling = 1,
    display = c("sp", "lc", "cn"),
    main = "shallowN RDA, sulfur and distance predictors")
spe.sc1 <-
    scores(shallowNenz.sulf.rda,
        choices = 1:2,
        scaling = 1,
        display = "sp"
)
arrows(0, 0,
    spe.sc1[, 1] * 0.92,
    spe.sc1[, 2] * 0.92,
    length = 0,
    lty = 1,
    col = "red"
)

#dev.off()

## one interesting article that mentions this gene
## as part of a general membrane bound nitrate 
## reductase operon, in Pseudomonas aeruginosa
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3568144/

## and even more interesting:
https://journals.asm.org/doi/10.1128/JB.181.17.5303-5308.1999
## in this article, this operon is proposed to be a
## "high-substrate-induced" operon, in E. coli.
## (= low-affinity system?)
## as in, it is expressed when there is lots of 
## nitrate

## and so on. 

## how about a dbRDA:


deepNenz.cap <- capscale(deepNenz[-1] ~ deepNenz$Distance, dist="bray")

deepNenz.cap

plot(deepNenz.cap) ## similar as with hellinger transformed, but less informative
anova(deepNenz.cap) ## nope nope nope 




## taking a univariate approach
## can we say there is a statistically significant 
## increase with distance of this gene?
## let's go back to...

### python ###

## back to python:

deepNARcounts = deepNenzT['narGHIJK'].reset_index(drop=True)
deepDist = deepNenzT.reset_index()['Distance']

narGHIJK_model = sm.GLM(
                    deepNARcounts, 
                    deepDist, 
                    family=sm.families.NegativeBinomial())

narGHIJK_results = narGHIJK_model.fit()

print(narGHIJK_results.summary())

## which gives us:

                 Generalized Linear Model Regression Results
==============================================================================
Dep. Variable:               narGHIJK   No. Observations:                    4
Model:                            GLM   Df Residuals:                        3
Model Family:        NegativeBinomial   Df Model:                            0
Link Function:                    Log   Scale:                          1.0000
Method:                          IRLS   Log-Likelihood:                -1396.2
Date:                Tue, 14 Jun 2022   Deviance:                       2722.8
Time:                        16:48:55   Pearson chi2:                 1.94e+06
No. Iterations:                    11   Pseudo R-squ. (CS):        -4.044e+295
Covariance Type:            nonrobust
==============================================================================
                 coef    std err          z      P>|z|      [0.025      0.975]
------------------------------------------------------------------------------
Distance       0.0223      0.001     15.627      0.000       0.020       0.025
==============================================================================

## hmm, I think I am reading that right, a very small p value. 

## just to make sure, use a function I am a little more familiar with:

deepNARcounts

deepDist

LinearRegression


X = deepDist.values.reshape(-1,1)
Y = deepNARcounts.values.reshape(-1,1)

reg = LinearRegression()

reg.fit(X,Y)

reg.predict(X)

reg.score()
## forgot, no frequentist pvalues for the sklearn people
## they can't be bothered with such dinosaurs

## so use scipy stats:

stats.linregress(deepDist, deepNARcounts) ## but can't fit negative binomial to this

## wonder what organism(s) this operon belongs to?


#### meeting todo list, after talking to Zhe:

## focus more on sulfur
## = rda of sulfur genes
## = look closely at dsrAB and soxYZAXB
## look for correlations between sulfur genes and NarG
## compare gene abundances by depth
## add confluence site to all charts
## model the change in slopes between depths at mid A and mid B 
## look for genes of interest in Sulfuricurvum?
## rerun the hellinger-transformed RDA of nitrogen as a dbRDA?


###### sulfur metabolism #######

## a good introduction is here:
https://doi.org/10.1111/j.1574-6976.2009.00187.x
## = Ghosh and Dam 2009

#### graph all sulfur genes

## probably a mess, but let's graph them all, and run an RDA on them
## might help us pickout genes to focus on


enzEnv

Senz = enz[enz.Function == "S metabolism"]


deepSamples

shallowSamples


## make sulphure gene matrix as above
deepSenz = (enz[enz.Function == "S metabolism"][deepSamples])
shallowSenz = (enz[enz.Function == "S metabolism"][shallowSamples])
aa = (deepSenz.reset_index()['enzyme']
        .str.split(pat="(", n=1, expand=True)[1]
        .str.replace(")","")
    )
aa.name = "enzyme"
deepSenz.index = aa
shallowSenz.index = aa
del(aa)
deepSenzT = deepSenz.transpose()
deepSenzT.index = deepDist
shallowSenzT = shallowSenz.transpose()
shallowSenzT.index = shallowDist
#deepSenzT.to_csv('deepSenz.csv')
#shallowSenzT.to_csv('shallowSenz.csv')

deepDist





fig1, ax1 = plt.subplots()
deepSenzT.plot.line(title='15cm S-metabolism gene counts', ax=ax1)

fig, ax = plt.subplots(2,1, sharex=True)
deepSenzT.plot.line(title='15cm S-metabolism gene counts', ax=ax[0], legend=False)
shallowSenzT.plot.line(title='5cm S-metabolism gene counts', ax=ax[1])

## interesting. We see the same shapes as with 
## the N-reducers in some of these enzymes. 

## I really hope Zhe did his normalizations right. 

## anyway, assuming he did...

## in the simplest scenario, we would expect sulfur
## oxidation in this system to be coupled with nitrate 
## reduction. So the congruency between some of these
## trends and the n-reducing genes is expected. 

## Zhe was especially interested in dsrAB and soxYZAXB
## soxYZAXB definitely shows a congruent trend as the
## the 

## according to wikipedia, dissimilatory sulfate reduction 
## is a respiration process with sulfate as the final 
## electron acceptor. 

## one would therefore expect activity of this enzyme this to be in competition 
## with reduction of nitrogen, no?

## a plot with just the two genes that Zhe wanted to look at:


plt.close('all')
shallowSenzT[['soxYZAXB', 'dsrAB']]
deepSenzT[['soxYZAXB', 'dsrAB']]
fig, ax = plt.subplots(2,1, sharex=True)
(deepSenzT[['soxYZAXB', 'dsrAB']]
    .plot.line(title='15cm S-metabolism gene counts', 
    ax=ax[0], legend=False))
(shallowSenzT[['soxYZAXB', 'dsrAB']]
    .plot.line(title='5cm S-metabolism gene counts', 
    ax=ax[1]))

## interesting, soxYZAXB behaves like we would expect.

## can we isolate just the genes that show a dramatic 
## difference between the two mid sites?

plt.close('all')
fig, ax = plt.subplots()
(shallowSenzT[['soxYZAXB', 'sat', 'sqr', 'soxC']]
    .plot.line(title='5cm S-metabolism gene counts', 
    ax=ax))
ax.set_xlim(0,550)
ax.set_ylim(0,3000)


## in the case of the 15cm depth, the genes that 
## show congruence with the n-reducers are:
## soxYZAXB', 'soxC', and 'sorAB'
## for 15cm depth, the genes that 
## show congruence with the n-reducers are:
## soxYZAXB', 'soxC', and 'sorAB'
## and for 5 cm:
## 'soxYZAXB', 'sat', 'sqr', 'soxC'

## we can also include dsrAB, a sulfur reducing 
## enzyme that Zhe was interested in, though: 
## 'dsrAB'

## that adds up to:

plt.close('all')
fig, ax = plt.subplots(2,1, sharex=True)
genes=['soxYZAXB', 'soxC', 'sat', 'sqr','dsrAB']
(deepSenzT[genes]
    .plot.line(title='15cm S-metabolism gene counts', 
    ax=ax[0], legend=False))
(shallowSenzT[genes]
    .plot.line(title='5cm S-metabolism gene counts', 
    ax=ax[1]))

## the two best examples of this are the promoter 'soxYZAXB'
## and the hydrogen sulfide ('sulfane') oxidizing enzyme 'soxC'

## sqr is some sort of sulfar-related quinone electron shuttle thing,
## I think. It also is probably bidirectional, as far as oxidation/reduction

## it is highly congruent in the deeper sediment, but not on the shallow
## sediments. 

## SAT is an enzyme for adenylating sulfate, and can be linked to both 
## oxidation and reducing pathways

#### correlations ####

## Zhe wanted to look for correlations between sulfur genes and NarG
## I'd say let's mash the sulfur and nitrogen genes together and make
## a correlation matrix. Again, broken up by depth.

## deep gene matrix, N + S  
## in python

deepSNcorr = (enz[(enz.Function == "S metabolism") | (enz.Function == "N metabolism")]
            [deepSamples]
            .transpose()
            .corr()
)

deepSNcorr ## looks okay

plt.close('all')
fig, ax = plt.subplots(figsize=(8,8))
im = ax.imshow(deepSNcorr)
ax.set_xticks(range(deepSNcorr.shape[0]))
ax.set_yticks(range(deepSNcorr.shape[0]))
ax.set_yticklabels(deepSNcorr.columns.to_list())
ax.set_xticklabels(deepSNcorr.columns.to_list(), rotation=90)
ax.set_title('S/N correlations, deep (15cm)', fontsize=20)
ax.vlines(x=8.5,
          ymin=-0.5,
          ymax=21.5,
          colors='black',
          linewidths=5
)
ax.hlines(y=8.5,
          xmax=-0.5,
          xmin=21.5,
          colors='black',
          linewidths=5
)
plt.tight_layout()

## need to tweak colormap. green = 0, blue = -1, yellow = 1
## good enough for now. 

## repeat for shallow:

shallowSNcorr = (enz[(enz.Function == "S metabolism") | (enz.Function == "N metabolism")]
            [shallowSamples]
            .transpose()
            .corr()
)


plt.close('all')
fig, ax = plt.subplots(figsize=(8,8))
im = ax.imshow(shallowSNcorr)
ax.set_xticks(range(shallowSNcorr.shape[0]))
ax.set_yticks(range(shallowSNcorr.shape[0]))
ax.set_yticklabels(shallowSNcorr.columns.to_list())
ax.set_xticklabels(shallowSNcorr.columns.to_list(), rotation=90)
ax.set_title('S/N correlations, shallow (5cm)', fontsize=20)
ax.vlines(x=8.5,
          ymin=-0.5,
          ymax=21.5,
          colors='black',
          linewidths=5
)
ax.hlines(y=8.5,
          xmax=-0.5,
          xmin=21.5,
          colors='black',
          linewidths=5
)
plt.tight_layout()


########## new homework ###########

## still need confluence data
## refine regression/correlation among N/S genes
## can we get a housekeeping gene like rpoB?
## explore Zhe's environmental data

##### confluence data ######
 
## let's repeat the above and get N and S gene matrices
## that include the confluence

## for N
deepSamples = enzEnv.loc["Depth"][enzEnv.loc["Depth"] == 0.15].index.to_list()
## that stays the same, we don't have confluence data for the deep
## this is different, we dropped confluence before:
shallowSamples = enzEnv.loc["Depth"][enzEnv.loc["Depth"] == 0.05].index.to_list()
deepDist = enzEnv[deepSamples].loc['Distance']
shallowDist = enzEnv[shallowSamples].loc['Distance']
deepNenz = (enz[enz.Function == "N metabolism"][deepSamples]
        .drop(axis='rows', labels='Ammonia monooxygenase (amoA)'))
shallowNenz = (enz[enz.Function == "N metabolism"][shallowSamples]
        .drop(axis='rows', labels='Ammonia monooxygenase (amoA)'))

## let's just keep the abbreviations:
aa = (deepNenz.reset_index()['enzyme']
        .str.split(pat="(", n=1, expand=True)[1]
        .str.replace(")","")
    )
aa.name = "enzyme"
deepNenz.index = aa
shallowNenz.index = aa

deepDist = enzEnv[deepSamples].loc['Distance']
deepNenzT = deepNenz.transpose()
deepNenzT.index = deepDist
deepNenzT

shallowDist = enzEnv[shallowSamples].loc['Distance']
shallowNenzT = shallowNenz.transpose()
shallowNenzT.index = shallowDist
shallowNenzT

## plotting N 
fig, ax = plt.subplots(2,1, sharex=True)
deepNenzT.plot.line(title='15cm N-reducing gene counts', ax=ax[0], legend=False)
shallowNenzT.plot.line(title='5cm N-reducing gene counts, including confluence', ax=ax[1])

## for Sulphur

## make sulphure gene matrix as above
deepSenz = (enz[enz.Function == "S metabolism"][deepSamples])
shallowSenz = (enz[enz.Function == "S metabolism"][shallowSamples])
aa = (deepSenz.reset_index()['enzyme']
        .str.split(pat="(", n=1, expand=True)[1]
        .str.replace(")","")
    )
aa.name = "enzyme"
deepSenz.index = aa
shallowSenz.index = aa
del(aa)
deepSenzT = deepSenz.transpose()
deepSenzT.index = deepDist
shallowSenzT = shallowSenz.transpose()
shallowSenzT.index = shallowDist

plt.close('all')

## plotting all sulphur related genes
fig, ax = plt.subplots(2,1, sharex=True)
deepSenzT.plot.line(title='15cm S-metabolism gene counts', ax=ax[0], legend=False)
shallowSenzT.plot.line(title='5cm S-metabolism gene counts, including confluence', ax=ax[1])

## subset to sulphur genes of interest:
fig, ax = plt.subplots(2,1, sharex=True)
genes=['soxYZAXB', 'soxC', 'sat', 'sqr','dsrAB']
(deepSenzT[genes]
    .plot.line(title='15cm S-metabolism gene counts', 
    ax=ax[0], legend=False))
(shallowSenzT[genes]
    .plot.line(title='5cm S-metabolism gene counts', 
    ax=ax[1]))

## subset to two unambiguous sulphur oxidizing genes:
fig, ax = plt.subplots(2,1, sharex=True)
genes=['soxYZAXB', 'soxC']
(deepSenzT[genes]
    .plot.line(title='15cm Sox gene counts', 
    ax=ax[0], legend=False))
(shallowSenzT[genes]
    .plot.line(title='5cm Sox gene counts', 
    ax=ax[1]))

## great, so adding the confluence made little difference

##### univariate regressions ####

## let's build some univariate models of nitrogen gene counts 
## as a function of sulfur oxidation genes (or vice versa)

## according to our RDAs, narGHIJK is most heavily, positively
## influenced by distance. 

## but I have trouble believing this entirely, looking at the 
## gene abundance charts. The same "lightning strike" shape 
## is visible in the deep (15cm) charts in both genes,
## and the same "upside-down check" in the shallow (5cm). 

## check with a good old fashioned regression, neg binom,
## as we did with distance above, @ "taking a univariate approach"

## repeat, with sox operon:

## back to python:

## with just the sox operon:
deepNARcounts = deepNenzT['narGHIJK'].reset_index(drop=True)
sox = deepSenzT['soxYZAXB'].reset_index(drop=True)
deep_narGHIJK_sox_model = sm.GLM(
                    deepNARcounts, 
                    sox, 
                    family=sm.families.NegativeBinomial())

deep_narGHIJK_sox_model_results = deep_narGHIJK_sox_model.fit()

print(deep_narGHIJK_sox_model_results.summary())

## multiple regression possible here? We just have 4 observations...

sox_deepDist = deepSenzT.reset_index()[['Distance','soxYZAXB']]
deepDist = deepNenzT.reset_index()['Distance']
sox = deepSenzT['soxYZAXB'].reset_index(drop=True)
deep_nar_by_soxDistance_model = sm.GLM(
                    deepNARcounts, 
                    sox_deepDist, 
                    family=sm.families.NegativeBinomial())

deep_nar_by_soxDistance_results = deep_nar_by_soxDistance_model.fit()

print(deep_nar_by_soxDistance_results.summary())

## both terms significant, but not much or any real coefficient, 
## I assume because the overall trends are almost flat, and 
## "slightly" opposite (slight positive vs. slight negative) 
## overall

## in general, somehow we need to focus our attention on the 
## real trend in the data, which are the slopes between 
## the two mid sites. I think this would be a comparison of 
## slopes 

## maybe get to that in a minute. 


## that is just not that useful. Why do so few regression
## functions include error families for count data? I must be
## missing something. 

## anyway, with shallow Nar operon

shallowNARcounts = shallowNenzT['narGHIJK'].reset_index(drop=True)
shallowDist = shallowNenzT.reset_index()['Distance']
sox = shallowSenzT['soxYZAXB'].reset_index(drop=True)
shallow_narGHIJK_sox_model = sm.GLM(
                    shallowNARcounts, 
                    sox, 
                    family=sm.families.NegativeBinomial())

shallow_narGHIJK_sox_model_results = shallow_narGHIJK_sox_model.fit()

print(shallow_narGHIJK_sox_model_results.summary())

## about the same. 

## well, at least it agrees with the RDA

## according to our RDA, narGHIJK should be mostly predicted by 
## distance, and norBC, napAB and nrfAH should all be better 
## predicted by the abundance of the sox operon.

def regrShallowNgeneAgainstSox(Ngene):
    shallowCounts = shallowNenzT[Ngene].reset_index(drop=True)
    shallowDist = shallowNenzT.reset_index()['Distance']
    sox = shallowSenzT['soxYZAXB'].reset_index(drop=True)
    model = sm.GLM(
                        shallowCounts, 
                        sox, 
                        family=sm.families.NegativeBinomial())
    model_results = model.fit()
    return(model_results.summary())

regrShallowNgeneAgainstSox("napAB")

regrShallowNgeneAgainstSox("nirBD")

regrShallowNgeneAgainstSox("nrfAH")

## none of this is convincing. I'm missing something here, I think
## I'm not 
## Let's look at some plots:
## https://medium.com/analytics-vidhya/linear-regression-using-pandas-numpy-for-beginners-in-data-science-fe57157ed93d

aa = (pd.concat([
    shallowNenzT["narGHIJK"],
    shallowNenzT["napAB"],
    shallowNenzT["nrfAH"],
    shallowNenzT["nirK"],
    shallowNenzT["nosZ"],
    shallowNenzT["nirS"],
    shallowSenzT["soxYZAXB"],
    ], 
    axis = "columns")
        .reset_index(drop=True)
)
aa['dist'] = shallowDist
shallowCorrs = aa.corr()
sns.pairplot(data=aa)

bb = (pd.concat([
    deepNenzT["narGHIJK"],
    deepNenzT["napAB"],
    deepNenzT["nrfAH"],
    deepNenzT["nirK"],
    deepNenzT["nosZ"],
    deepNenzT["nirS"],
    deepSenzT["soxYZAXB"],
    ], 
    axis = "columns")
        .reset_index(drop=True)
)
bb['dist'] = deepDist
deepCorrs = bb.corr()

sns.pairplot(data=bb)

deepCorrs

sns.jointplot(x='napAB',y='nirS', data=deepNenzT)
sns.jointplot(x='napAB',y='nirS', data=deepNenzT)

## this is all too messy. 
## we need to start attaching some confidence to these

## tomorrow, get some models for assocatiations with sox operon


